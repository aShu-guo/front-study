//异步操作
/*
任务分为两种：同步任务和异步任务
同步任务：前面任务执行完了，后面任务才能执行。容易出现堵塞
异步任务：没有进入主线程，而进入的任务队列的任务。排在异步任务后面的代码，不会等待异步任务执行完毕后再执行
 */
//js运行时，包括两个部分，一个是主线程，另外一个是异步任务队列
/*
执行顺序是：主线程先执行完同步任务，后去任务队列有没有满足执行条件的异步任务；如果有则进入主线程执行，无则继续等待
异步任务的写法通常是回调函数，如果一个异步任务没有回调函数，那么就不会被执行
 */

//异步操作的模式
//1.回调函数 优点：简便，容易理解 缺点：相互嵌套，发生错误不易分析
function f1(callback) {
  callback();
}

function f2() {

}

//f1会等f2执行完之后才执行
f2(f1);

//2.时间监听机制 优点：可以绑定多个事件，去耦合，有利于模块化。缺点：每个事件分散在代码中，不易看出主流程；而且整个程序都要改成事件驱动型
// f1.on('done',f2);

//3.发布和订阅（观察者模式）
//f1订阅消息中心，f2执行完毕后，向信息中心发布执行完毕信息后执行f1

//多个异步任务的执行顺序问题
//串行、并行、串行与并行结合
/*
串行：顺序执行，后面任务等待前面任务执行完才执行 效率低
并行：多个异步任务一起执行 效率高，容易耗尽系统资源
串行与并行结合：设置一个门槛，每次只并行执行limit个异步任务
 */

//定时器
//setTimeout(func | code, delay);
//在delay毫秒后，执行func或一段code
//也可传入多个参数，多传的参数会作为函数的参数传递
setTimeout(function (a, b) {
  console.log(a, b);
}, 1000, 1, 2);

//setInverval() 每隔一段时间执行一次 必须要等到当前脚本的同步任务全部执行后再执行
setInterval(function () {
  console.log(2);
}, 1000);
//如果定时任务执行时间超出定时任务间隔，那么前一个任务执行完毕后会立刻执行下一次；所以setInterval()设置的时间并不是每次都会按规定时间执行
//为了确保任务执行间隔固定，可以用setTimeout()指定下次任务的执行时间
setTimeout(function f() {
  setTimeout(f, 2000);
}, 2000);

//由于setTimeout() setInterval()会返回一个连续的整数值 必须要等到当前脚本的同步任务全部执行后再执行

//清除所有定时器
function clear() {
  var i = setTimeout(function () {
  }, 0);
  while (i >= 0) {
    clearTimeout(i--);
  }
}

//实际上，setTimeout(f, 0)不会真的在0毫秒之后运行，不同的浏览器有不同的实现。

//setTimeout一些重要应用??

//Promise对象


